otu.tab <- as.matrix(otu.tab)
row.sum <- rowSums(otu.tab)
otu.tab <- otu.tab / row.sum
n <- nrow(otu.tab)
# Construct the returning array
if (is.null(rownames(otu.tab))) {
rownames(otu.tab) <- paste("comm", 1:n, sep="_")
}
# Check OTU name consistency
if (sum(!(colnames(otu.tab) %in% tree$tip.label)) != 0) {
stop("The OTU table contains unknown OTUs! OTU names
in the OTU table and the tree should match!" )
}
# Get the subtree if tree contains more OTUs
absent <- tree$tip.label[!(tree$tip.label %in% colnames(otu.tab))]
if (length(absent) != 0) {
tree <- drop.tip(tree, absent)
warning("The tree has more OTU than the OTU table!")
}
# Reorder the otu.tab matrix if the OTU orders are different
tip.label <- tree$tip.label
otu.tab <- otu.tab[, tip.label]
ntip <- length(tip.label)
nbr <- nrow(tree$edge)
edge <- tree$edge
edge2 <- edge[, 2]
br.len <- tree$edge.length  # branch length
#  Accumulate OTU proportions up the tree
cum <- matrix(0, nbr, n)							# Branch abundance matrix
for (i in 1:ntip) {
tip.loc <- which(edge2 == i)
cum[tip.loc, ] <- cum[tip.loc, ] + otu.tab[, i]
node <- edge[tip.loc, 1]						# Assume the direction of edge
node.loc <- which(edge2 == node)
while (length(node.loc)) {
cum[node.loc, ] <- cum[node.loc, ] + otu.tab[, i]
node <- edge[node.loc, 1]
node.loc <- which(edge2 == node)
}
}
if(is.null(tree$node.label)) tree$node.label <- paste("Node", 1:tree$Nnode, sep = "")
all.labels <- c(tree$tip.label, tree$node.label)
cum.labels <- all.labels[tree$edge[, 2]]
out = list(cum = cum, br.len = br.len, cum.labels = cum.labels)
return(out)
}
perm.mar.cov <- function(Y, X, binary = FALSE, cov = NULL, nperm, seed) {
n <- nrow(X)
if(is.null(cov)) cov <- rep(1, n)
## fit the null model
model <- ifelse(binary, "binomial", "gaussian")
null.model <- glm(trait ~ ., family = model, data = data.frame(trait = Y, cov))
## regress each OTU on covariates
Xres <- resid(lm(X ~ ., data = data.frame(cov)))
weight <- apply(X, 2, sd)
weight[apply(Xres, 2, sd) == 0] <- 0
## calculate score test statistics U
## permute X residuals and calculate permutation Us
## calculate p-values in return
U <- glm.scoretest(null.model, Xres)
set.seed(seed)
perm.id <- replicate(nperm, sample(1:n))
U.perm <- apply(perm.id, 2, function(x) glm.scoretest(null.model, Xres[x, ]))
Up <- cbind(U, U.perm)
rm(U, U.perm, Xres, X)
gc()
return(list(pval.1side = pnorm(Up), weight = weight))
## pval.1side are the one-sided p-values; can be further used by AF_combine functions
}
select.l.u <- function(lowerlist, upperlist, com, label){
sel.lower <- c()
sel.upper <- c()
if(1 %in% com) sel.lower <- label[lowerlist]
if(2 %in% com) sel.upper <- label[upperlist]
return(list(lower = sel.lower, upper = sel.upper))
}
#' Associated taxa selected by combining p-values of four tests using different abundance representations
#'
#' @param sel.unweight The list of selected associated taxa by unweighted UniFrac-like test.
#' @param sel.weight The list of selected associated taxa by weighted UniFrac-like test.
#' @param sel.5 The list of selected associated taxa by generalized UniFrac-like test.
#' @param sel.tip The list of selected associated taxa by leaf-nodes-only test.
#' @param com The index of selected tests using different abundance representations.
#'            1: unweighted UniFrac-like test.
#'            2: weighted UniFrac-like test.
#'            3: generalized UniFrac-like test.
#'            4: leaf-nodes-only test.
#'
#' @return A list of selected associated taxa after combining four using different abundance representations:
#'         \item{lower}{Under-presented taxa based on lower-tail p-values.}
#'         \item{upper}{Over-presented taxa based on upper-tail p-values.}
#'
#' @export
#'
select.com <- function(sel.unweight, sel.weight, sel.5, sel.tip, com){
sel.lower <- c()
sel.upper <- c()
if(1 %in% com){
sel.lower <- sel.unweight$lower
sel.upper <- sel.unweight$upper
}
if(2 %in% com){
sel.lower <- c(sel.lower, sel.weight$lower)
sel.upper <- c(sel.upper, sel.weight$upper)
}
if(3 %in% com){
sel.lower <- c(sel.lower, sel.5$lower)
sel.upper <- c(sel.upper, sel.5$upper)
}
if(4 %in% com){
sel.lower <- c(sel.lower, sel.tip$lower)
sel.upper <- c(sel.upper, sel.tip$upper)
}
sel.lower <- unique(sel.lower)
sel.upper <- unique(sel.upper)
return(list(lower = sel.lower, upper = sel.upper))
}
Y = y
X = as.matrix(throat.otu.tab)
tree = throat.tree
cov = zcov
model = "binomial"
n.perm = 999
seed = 1234
model <- match.arg(model)
model
model <- match.arg(model)
xt.prop <- cum_prop(X, tree)
model <- match.arg(model, choices = c("gaussian", "binomial"))
ext.prop <- cum_prop(X, tree)
library(ape)
cum_prop(X, tree)
AF_combine <- function(p, weight = 1, log = TRUE) {
if(!log) {
p <- log(p)
}
B <- ncol(p)
wp <- p * weight
s <- apply(apply(wp, 2, sort), 2, cumsum)
ps.all <- t(apply(s, 1, rank, ties.method = "max"))/B
rm(s)
gc()
AF.all <- apply(ps.all, 2, min)
which.select <- order(wp[, 1])[1:which.min(ps.all[, 1])]
p.all <- rank(AF.all, ties.method = "max")/B
AF.list <- list(
pvalue = p.all,
which.selected = which.select
)
return(AF.list)
}
cum_prop <- function (otu.tab, tree) {
#if (!is.rooted(tree)) stop("Rooted phylogenetic tree required!")
# Convert into proportions
otu.tab <- as.matrix(otu.tab)
row.sum <- rowSums(otu.tab)
otu.tab <- otu.tab / row.sum
n <- nrow(otu.tab)
# Construct the returning array
if (is.null(rownames(otu.tab))) {
rownames(otu.tab) <- paste("comm", 1:n, sep="_")
}
# Check OTU name consistency
if (sum(!(colnames(otu.tab) %in% tree$tip.label)) != 0) {
stop("The OTU table contains unknown OTUs! OTU names
in the OTU table and the tree should match!" )
}
# Get the subtree if tree contains more OTUs
absent <- tree$tip.label[!(tree$tip.label %in% colnames(otu.tab))]
if (length(absent) != 0) {
tree <- drop.tip(tree, absent)
warning("The tree has more OTU than the OTU table!")
}
# Reorder the otu.tab matrix if the OTU orders are different
tip.label <- tree$tip.label
otu.tab <- otu.tab[, tip.label]
ntip <- length(tip.label)
nbr <- nrow(tree$edge)
edge <- tree$edge
edge2 <- edge[, 2]
br.len <- tree$edge.length  # branch length
#  Accumulate OTU proportions up the tree
cum <- matrix(0, nbr, n)							# Branch abundance matrix
for (i in 1:ntip) {
tip.loc <- which(edge2 == i)
cum[tip.loc, ] <- cum[tip.loc, ] + otu.tab[, i]
node <- edge[tip.loc, 1]						# Assume the direction of edge
node.loc <- which(edge2 == node)
while (length(node.loc)) {
cum[node.loc, ] <- cum[node.loc, ] + otu.tab[, i]
node <- edge[node.loc, 1]
node.loc <- which(edge2 == node)
}
}
if(is.null(tree$node.label)) tree$node.label <- paste("Node", 1:tree$Nnode, sep = "")
all.labels <- c(tree$tip.label, tree$node.label)
cum.labels <- all.labels[tree$edge[, 2]]
out = list(cum = cum, br.len = br.len, cum.labels = cum.labels)
return(out)
}
perm.mar.cov <- function(Y, X, binary = FALSE, cov = NULL, nperm, seed) {
n <- nrow(X)
if(is.null(cov)) cov <- rep(1, n)
## fit the null model
model <- ifelse(binary, "binomial", "gaussian")
null.model <- glm(trait ~ ., family = model, data = data.frame(trait = Y, cov))
## regress each OTU on covariates
Xres <- resid(lm(X ~ ., data = data.frame(cov)))
weight <- apply(X, 2, sd)
weight[apply(Xres, 2, sd) == 0] <- 0
## calculate score test statistics U
## permute X residuals and calculate permutation Us
## calculate p-values in return
U <- glm.scoretest(null.model, Xres)
set.seed(seed)
perm.id <- replicate(nperm, sample(1:n))
U.perm <- apply(perm.id, 2, function(x) glm.scoretest(null.model, Xres[x, ]))
Up <- cbind(U, U.perm)
rm(U, U.perm, Xres, X)
gc()
return(list(pval.1side = pnorm(Up), weight = weight))
## pval.1side are the one-sided p-values; can be further used by AF_combine functions
}
select.l.u <- function(lowerlist, upperlist, com, label){
sel.lower <- c()
sel.upper <- c()
if(1 %in% com) sel.lower <- label[lowerlist]
if(2 %in% com) sel.upper <- label[upperlist]
return(list(lower = sel.lower, upper = sel.upper))
}
#' Associated taxa selected by combining p-values of four tests using different abundance representations
#'
#' @param sel.unweight The list of selected associated taxa by unweighted UniFrac-like test.
#' @param sel.weight The list of selected associated taxa by weighted UniFrac-like test.
#' @param sel.5 The list of selected associated taxa by generalized UniFrac-like test.
#' @param sel.tip The list of selected associated taxa by leaf-nodes-only test.
#' @param com The index of selected tests using different abundance representations.
#'            1: unweighted UniFrac-like test.
#'            2: weighted UniFrac-like test.
#'            3: generalized UniFrac-like test.
#'            4: leaf-nodes-only test.
#'
#' @return A list of selected associated taxa after combining four using different abundance representations:
#'         \item{lower}{Under-presented taxa based on lower-tail p-values.}
#'         \item{upper}{Over-presented taxa based on upper-tail p-values.}
#'
#' @export
#'
select.com <- function(sel.unweight, sel.weight, sel.5, sel.tip, com){
sel.lower <- c()
sel.upper <- c()
if(1 %in% com){
sel.lower <- sel.unweight$lower
sel.upper <- sel.unweight$upper
}
if(2 %in% com){
sel.lower <- c(sel.lower, sel.weight$lower)
sel.upper <- c(sel.upper, sel.weight$upper)
}
if(3 %in% com){
sel.lower <- c(sel.lower, sel.5$lower)
sel.upper <- c(sel.upper, sel.5$upper)
}
if(4 %in% com){
sel.lower <- c(sel.lower, sel.tip$lower)
sel.upper <- c(sel.upper, sel.tip$upper)
}
sel.lower <- unique(sel.lower)
sel.upper <- unique(sel.upper)
return(list(lower = sel.lower, upper = sel.upper))
}
ext.prop <- cum_prop(X, tree)
cum <- ext.prop$cum
cum
cum.labels <- ext.prop$cum.labels
br.len <- ext.prop$br.len
## weighted test
if(is.null(seed)) seed <- sample(10000, 1)
p.w <- perm.mar.cov(Y, t(cum), binary = (model == "binomial"), cov = cov, nperm = n.perm, seed = seed)
install.packages("statmod")
library(statmod)
AF_combine <- function(p, weight = 1, log = TRUE) {
if(!log) {
p <- log(p)
}
B <- ncol(p)
wp <- p * weight
s <- apply(apply(wp, 2, sort), 2, cumsum)
ps.all <- t(apply(s, 1, rank, ties.method = "max"))/B
rm(s)
gc()
AF.all <- apply(ps.all, 2, min)
which.select <- order(wp[, 1])[1:which.min(ps.all[, 1])]
p.all <- rank(AF.all, ties.method = "max")/B
AF.list <- list(
pvalue = p.all,
which.selected = which.select
)
return(AF.list)
}
cum_prop <- function (otu.tab, tree) {
#if (!is.rooted(tree)) stop("Rooted phylogenetic tree required!")
# Convert into proportions
otu.tab <- as.matrix(otu.tab)
row.sum <- rowSums(otu.tab)
otu.tab <- otu.tab / row.sum
n <- nrow(otu.tab)
# Construct the returning array
if (is.null(rownames(otu.tab))) {
rownames(otu.tab) <- paste("comm", 1:n, sep="_")
}
# Check OTU name consistency
if (sum(!(colnames(otu.tab) %in% tree$tip.label)) != 0) {
stop("The OTU table contains unknown OTUs! OTU names
in the OTU table and the tree should match!" )
}
# Get the subtree if tree contains more OTUs
absent <- tree$tip.label[!(tree$tip.label %in% colnames(otu.tab))]
if (length(absent) != 0) {
tree <- drop.tip(tree, absent)
warning("The tree has more OTU than the OTU table!")
}
# Reorder the otu.tab matrix if the OTU orders are different
tip.label <- tree$tip.label
otu.tab <- otu.tab[, tip.label]
ntip <- length(tip.label)
nbr <- nrow(tree$edge)
edge <- tree$edge
edge2 <- edge[, 2]
br.len <- tree$edge.length  # branch length
#  Accumulate OTU proportions up the tree
cum <- matrix(0, nbr, n)							# Branch abundance matrix
for (i in 1:ntip) {
tip.loc <- which(edge2 == i)
cum[tip.loc, ] <- cum[tip.loc, ] + otu.tab[, i]
node <- edge[tip.loc, 1]						# Assume the direction of edge
node.loc <- which(edge2 == node)
while (length(node.loc)) {
cum[node.loc, ] <- cum[node.loc, ] + otu.tab[, i]
node <- edge[node.loc, 1]
node.loc <- which(edge2 == node)
}
}
if(is.null(tree$node.label)) tree$node.label <- paste("Node", 1:tree$Nnode, sep = "")
all.labels <- c(tree$tip.label, tree$node.label)
cum.labels <- all.labels[tree$edge[, 2]]
out = list(cum = cum, br.len = br.len, cum.labels = cum.labels)
return(out)
}
perm.mar.cov <- function(Y, X, binary = FALSE, cov = NULL, nperm, seed) {
n <- nrow(X)
if(is.null(cov)) cov <- rep(1, n)
## fit the null model
model <- ifelse(binary, "binomial", "gaussian")
null.model <- glm(trait ~ ., family = model, data = data.frame(trait = Y, cov))
## regress each OTU on covariates
Xres <- resid(lm(X ~ ., data = data.frame(cov)))
weight <- apply(X, 2, sd)
weight[apply(Xres, 2, sd) == 0] <- 0
## calculate score test statistics U
## permute X residuals and calculate permutation Us
## calculate p-values in return
U <- glm.scoretest(null.model, Xres)
set.seed(seed)
perm.id <- replicate(nperm, sample(1:n))
U.perm <- apply(perm.id, 2, function(x) glm.scoretest(null.model, Xres[x, ]))
Up <- cbind(U, U.perm)
rm(U, U.perm, Xres, X)
gc()
return(list(pval.1side = pnorm(Up), weight = weight))
## pval.1side are the one-sided p-values; can be further used by AF_combine functions
}
select.l.u <- function(lowerlist, upperlist, com, label){
sel.lower <- c()
sel.upper <- c()
if(1 %in% com) sel.lower <- label[lowerlist]
if(2 %in% com) sel.upper <- label[upperlist]
return(list(lower = sel.lower, upper = sel.upper))
}
#' Associated taxa selected by combining p-values of four tests using different abundance representations
#'
#' @param sel.unweight The list of selected associated taxa by unweighted UniFrac-like test.
#' @param sel.weight The list of selected associated taxa by weighted UniFrac-like test.
#' @param sel.5 The list of selected associated taxa by generalized UniFrac-like test.
#' @param sel.tip The list of selected associated taxa by leaf-nodes-only test.
#' @param com The index of selected tests using different abundance representations.
#'            1: unweighted UniFrac-like test.
#'            2: weighted UniFrac-like test.
#'            3: generalized UniFrac-like test.
#'            4: leaf-nodes-only test.
#'
#' @return A list of selected associated taxa after combining four using different abundance representations:
#'         \item{lower}{Under-presented taxa based on lower-tail p-values.}
#'         \item{upper}{Over-presented taxa based on upper-tail p-values.}
#'
#' @export
#'
select.com <- function(sel.unweight, sel.weight, sel.5, sel.tip, com){
sel.lower <- c()
sel.upper <- c()
if(1 %in% com){
sel.lower <- sel.unweight$lower
sel.upper <- sel.unweight$upper
}
if(2 %in% com){
sel.lower <- c(sel.lower, sel.weight$lower)
sel.upper <- c(sel.upper, sel.weight$upper)
}
if(3 %in% com){
sel.lower <- c(sel.lower, sel.5$lower)
sel.upper <- c(sel.upper, sel.5$upper)
}
if(4 %in% com){
sel.lower <- c(sel.lower, sel.tip$lower)
sel.upper <- c(sel.upper, sel.tip$upper)
}
sel.lower <- unique(sel.lower)
sel.upper <- unique(sel.upper)
return(list(lower = sel.lower, upper = sel.upper))
}
if(is.null(seed)) seed <- sample(10000, 1)
p.w <- perm.mar.cov(Y, t(cum), binary = (model == "binomial"), cov = cov, nperm = n.perm, seed = seed)
weight.w <- c(br.len) * p.w$weight
weight.w.nz <- weight.w[weight.w != 0]
p1.w <- p.w$pval.1side[weight.w != 0, ]
cur.wUniFrac.l <- AF_combine(p1.w, weight = weight.w.nz, log = FALSE)
cur.wUniFrac.u <- AF_combine(1 - p1.w, weight = weight.w.nz, log = FALSE)
rm(p.w, ext.prop, p1.w, weight.w.nz)
gc()
cur.wUniFrac <- AF_combine(rbind(cur.wUniFrac.l$pvalue, cur.wUniFrac.u$pvalue), weight = 1, log = FALSE)
sel.w <- select.l.u(cur.wUniFrac.l$which.selected, cur.wUniFrac.u$which.selected, com = cur.wUniFrac$which.selected, cum.labels[weight.w != 0])
rm(weight.w, cur.wUniFrac.l, cur.wUniFrac.u)
gc()
cum.u <- cum
cum.u[cum.u != 0] <- 1
p.u <- perm.mar.cov(Y, t(cum.u), binary = (model == "binomial"), cov = cov, nperm = n.perm, seed = seed)
weight.u <- c(br.len) * p.u$weight
weight.u.nz <- weight.u[weight.u != 0]
p1.u <- p.u$pval.1side[weight.u != 0, ]
cur.UniFrac.l <- AF_combine(p1.u, weight = weight.u.nz, log = FALSE)
cur.UniFrac.u <- AF_combine(1 - p1.u, weight = weight.u.nz, log = FALSE)
rm(p.u, p1.u, weight.u.nz)
gc()
cur.UniFrac <- AF_combine(rbind(cur.UniFrac.l$pvalue, cur.UniFrac.u$pvalue), weight = 1, log = FALSE)
sel.u <- select.l.u(cur.UniFrac.l$which.selected, cur.UniFrac.u$which.selected, com = cur.UniFrac$which.selected, cum.labels[weight.u != 0])
rm(cur.UniFrac.l, cur.UniFrac.u, weight.u)
gc()
cum.5 <- sqrt(cum)
p.5 <- perm.mar.cov(Y, t(cum.5), binary = (model == "binomial"), cov = cov, nperm = n.perm, seed = seed)
weight.5 <- c(br.len) * p.5$weight
weight.5.nz <- weight.5[weight.5 != 0]
p1.5 <- p.5$pval.1side[weight.5 != 0, ]
cur.UniFrac5.l <- AF_combine(p1.5, weight = weight.5.nz, log = FALSE)
cur.UniFrac5.u <- AF_combine(1 - p1.5, weight = weight.5.nz, log = FALSE)
rm(p.5, cum, p1.5, weight.5.nz)
gc()
cur.UniFrac5 <- AF_combine(rbind(cur.UniFrac5.l$pvalue, cur.UniFrac5.u$pvalue), weight = 1, log = FALSE)
sel.5 <- select.l.u(cur.UniFrac5.l$which.selected, cur.UniFrac5.u$which.selected, com = cur.UniFrac5$which.selected, cum.labels[weight.5 != 0])
rm(cur.UniFrac5.l, cur.UniFrac5.u, weight.5)
gc()
# leaf-nodes-only test
tip.cum <- X/rowSums(X) #only tip
p.tip <- perm.mar.cov(Y, tip.cum, binary = (model == "binomial"), cov = cov, nperm = n.perm, seed = seed)
weight.tip <- p.tip$weight
weight.tip.nz <- weight.tip[weight.tip != 0]
p1.tip <- p.tip$pval.1side[weight.tip != 0, ]
cur.tip.l <- AF_combine(p1.tip, weight = weight.tip.nz, log = FALSE)
cur.tip.u <- AF_combine(1 - p1.tip, weight = weight.tip.nz, log = FALSE)
rm(p.tip, p1.tip, weight.tip.nz)
gc()
cur.tip <- AF_combine(rbind(cur.tip.l$pvalue, cur.tip.u$pvalue), weight = 1, log = FALSE)
sel.tip <- select.l.u(cur.tip.l$which.selected, cur.tip.u$which.selected, com = cur.tip$which.selected, colnames(X))
rm(cur.tip.l, cur.tip.u, weight.tip)
gc()
cur.UniFrac$pvalue
rbind(cur.UniFrac$pvalue, cur.wUniFrac$pvalue, cur.UniFrac5$pvalue, cur.tip$pvalue)
cur.wUniFrac.l$pvalue
p.w <- perm.mar.cov(Y, t(cum), binary = (model == "binomial"), cov = cov, nperm = n.perm, seed = seed)
cur.UniFrac5.l
cur.tip
setwd("/Users/yiqianzhang/Desktop/Betadiag")
usethis::use_namespace()
usethis::use_namespace()
usethis::use_namespace()
usethis::use_namespace()
usethis::use_namespace()
library(devtools)
devtools::document()
devtools::build()
devtools::load_all()
check_distance()
devtools::load_all()
check_distance()
devtools::check()
.Last.error
devtools::check()
devtools::check()
devtools::check()
usethis::use_namespace()
devtools::document()
devtools::check()
euclidean_check()
library(devtools)
devtools::install_github("bioscinema/Betadiag")
euclidean_check()
pcoa_gower()
library(Betadiag)
euclidean_check()
pcoa_gower()
?Betadiag:::pcoa_gower()
check_distance()
Betadiag:::pcoa_gower()
